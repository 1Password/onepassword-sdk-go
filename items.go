// Code generated by op-codegen - DO NOT EDIT

package onepassword

import (
	"context"
	"encoding/json"
	"slices"
	"strings"

	"github.com/1password/onepassword-sdk-go/internal"
)

// The Items API holds all operations the SDK client can perform on 1Password items.
type ItemsAPI interface {
	// Create a new item
	Create(ctx context.Context, params ItemCreateParams) (Item, error)

	// Get an item by vault and item ID
	Get(ctx context.Context, vaultId string, itemId string) (Item, error)

	// Update an existing item.
	Put(ctx context.Context, item Item) (Item, error)

	// Delete an item.
	Delete(ctx context.Context, vaultId string, itemId string) error

	// List all items
	ListAll(ctx context.Context, vaultId string, filters ...Filter) (*Iterator[ItemOverview], error)
}

type ItemsSource struct {
	internal.InnerClient
}

func NewItemsSource(inner internal.InnerClient) *ItemsSource {
	return &ItemsSource{inner}
}

// Create a new item
func (s ItemsSource) Create(ctx context.Context, params ItemCreateParams) (Item, error) {
	resultString, err := clientInvoke(ctx, s.InnerClient, "ItemsCreate", map[string]interface{}{
		"params": params,
	})
	if err != nil {
		return Item{}, err
	}
	var result Item
	err = json.Unmarshal([]byte(*resultString), &result)
	if err != nil {
		return Item{}, err
	}
	return result, nil
}

// Get an item by vault and item ID
func (s ItemsSource) Get(ctx context.Context, vaultId string, itemId string) (Item, error) {
	resultString, err := clientInvoke(ctx, s.InnerClient, "ItemsGet", map[string]interface{}{
		"vault_id": vaultId,
		"item_id":  itemId,
	})
	if err != nil {
		return Item{}, err
	}
	var result Item
	err = json.Unmarshal([]byte(*resultString), &result)
	if err != nil {
		return Item{}, err
	}
	return result, nil
}

// Update an existing item.
func (s ItemsSource) Put(ctx context.Context, item Item) (Item, error) {
	resultString, err := clientInvoke(ctx, s.InnerClient, "ItemsPut", map[string]interface{}{
		"item": item,
	})
	if err != nil {
		return Item{}, err
	}
	var result Item
	err = json.Unmarshal([]byte(*resultString), &result)
	if err != nil {
		return Item{}, err
	}
	return result, nil
}

// Delete an item.
func (s ItemsSource) Delete(ctx context.Context, vaultId string, itemId string) error {
	_, err := clientInvoke(ctx, s.InnerClient, "ItemsDelete", map[string]interface{}{
		"vault_id": vaultId,
		"item_id":  itemId,
	})
	return err
}

// List all items
func (s ItemsSource) ListAll(ctx context.Context, vaultId string, filters ...Filter) (*Iterator[ItemOverview], error) {
	resultString, err := clientInvoke(ctx, s.InnerClient, "ItemsListAll", map[string]interface{}{
		"vault_id": vaultId,
	})
	if err != nil {
		return nil, err
	}
	var result []ItemOverview
	err = json.Unmarshal([]byte(*resultString), &result)
	if err != nil {
		return nil, err
	}

	if len(filters) == 0 {
		return NewIterator(result), nil
	}

	var filteredResult []ItemOverview
	for _, overview := range result {
		ok, err := applyFilters(s, ctx, overview, filters...)
		if err != nil {
			return nil, err
		}
		if ok {
			filteredResult = append(filteredResult, overview)
		}
	}

	return NewIterator(filteredResult), nil
}

func applyFilters(s ItemsSource, ctx context.Context, overview ItemOverview, filters ...Filter) (bool, error) {
	for _, filter := range filters {
		ok, err := filter(s, ctx, overview)
		if err != nil {
			return false, err
		}
		if !ok {
			return false, nil
		}
	}
	return true, nil
}

type Filter func(ItemsSource, context.Context, ItemOverview) (bool, error)

func WithTitleSuffix(s string) Filter {
	return func(_ ItemsSource, ctx context.Context, overview ItemOverview) (bool, error) {
		return strings.HasSuffix(overview.Title, s), nil
	}
}

func WithTitlePrefix(s string) Filter {
	return func(_ ItemsSource, ctx context.Context, overview ItemOverview) (bool, error) {
		return strings.HasPrefix(overview.Title, s), nil
	}
}

func WithTitleContains(s string) Filter {
	return func(_ ItemsSource, ctx context.Context, overview ItemOverview) (bool, error) {
		return strings.Contains(overview.Title, s), nil
	}
}

func WithTitle(title string) Filter {
	return func(_ ItemsSource, ctx context.Context, overview ItemOverview) (bool, error) {
		return overview.Title == title, nil
	}
}

func WithCategory(category ItemCategory) Filter {
	return func(_ ItemsSource, _ context.Context, overview ItemOverview) (bool, error) {
		return overview.Category == category, nil
	}
}

func WithTags(tags ...string) Filter {
	return func(s ItemsSource, ctx context.Context, overview ItemOverview) (bool, error) {
		item, err := s.Get(ctx, overview.VaultID, overview.ID)
		if err != nil {
			return false, err
		}
		for _, tag := range tags {
			if !slices.Contains(item.Tags, tag) {
				return false, nil
			}
		}
		return true, nil
	}
}
